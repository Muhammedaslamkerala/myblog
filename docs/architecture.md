
```markdown
# üèóÔ∏è System Architecture

This document provides a high-level overview of the architectural design, data flows, and infrastructure components of the **MyBlog** platform.

The system relies on a **Hybrid Modular Monolithic Architecture**, combining standard synchronous web practices (Django MVT) with modern asynchronous event-driven patterns (ASGI/WebSockets).

---

## üß© High-Level Design Diagram

The following diagram illustrates how a user request flows through the system components.

```mermaid
graph TD
    User[User / Client Browser]
    
    subgraph "Web Server Layer"
        Daphne[Daphne ASGI Server]
    end

    subgraph "Application Layer"
        Django[Django Views (Sync)]
        Channels[Django Channels (Async)]
    end

    subgraph "Background Processing"
        Redis[Redis (Broker & Cache)]
        Celery[Celery Workers]
    end

    subgraph "Data & AI"
        DB[(Database - SQLite/Postgres)]
        Groq[Groq API (Llama 3)]
    end

    %% Flows
    User -- "HTTP (GET/POST)" --> Daphne
    User -- "WebSocket (ws://)" --> Daphne

    Daphne -- "HTTP Routing" --> Django
    Daphne -- "WS Routing" --> Channels

    Django -- "CRUD Operations" --> DB
    Channels -- "Read/Write" --> DB

    Django -- "Trigger Task" --> Redis
    Channels -- "Pub/Sub Messaging" --> Redis

    Redis -- "Distribute Task" --> Celery
    Celery -- "Update Data" --> DB
    Celery -- "AI Inference" --> Groq
    
    Groq -- "Tags/Embeddings" --> Celery
```

---

## üè¢ Architectural Layers

### 1. Presentation Layer (Frontend)
*   **Technology:** Django Templates (HTML5), HTMX, JavaScript, Bootstrap/Tailwind.
*   **Responsibility:** Renders the UI and handles client-side interactions.
*   **Dynamic Updates:** Uses **HTMX** for AJAX-like updates (e.g., Liking a post) and **WebSockets** for live chat/notifications.

### 2. Application Layer (Backend)
This layer acts as the brain of the application, split into two execution modes:

*   **Synchronous (WSGI Mode - Django Views):**
    *   Handles standard HTTP requests (Login, Register, Create Post, Read Blog).
    *   Follows the **MVT (Model-View-Template)** design pattern.
*   **Asynchronous (ASGI Mode - Django Channels):**
    *   Handles long-lived connections (WebSockets).
    *   Manages the **RAG Chatbot** streaming response and **Real-Time Notifications**.

### 3. Asynchronous Task Layer
To ensure the website remains fast, heavy computations are offloaded to background workers.

*   **Celery:** Distributed task queue.
    *   *Job 1:* Sending SMTP Emails (OTP, Welcome emails).
    *   *Job 2:* üß† **AI Processing:** When a post is saved, Celery chunks the text and generates Vector Embeddings.
    *   *Job 3:* Auto-classification and Tagging via Groq API.
*   **Redis:**
    *   Acts as the **Message Broker** for Celery.
    *   Acts as the **Channel Layer** for WebSockets, allowing different instances of the app to broadcast messages (e.g., "User A liked User B's post").

### 4. Data Layer
*   **Relational Database:** Stores Users, Posts, Comments, and Profiles.
*   **Vector Storage:** We store high-dimensional vector embeddings (generated by `sentence-transformers`) directly in a JSONField within the Database. This allows for vector similarity search using Cosine Similarity logic implemented in NumPy.

---

## üîÑ Data Flow Scenarios

### Scenario A: Creating a New Post (AI Pipeline)
1.  **User** submits the "Create Post" form.
2.  **Django View** saves the post to the Database with status `Draft`.
3.  **Django Signals** trigger an asynchronous **Celery Task**.
4.  **Celery Worker** picks up the task:
    *   Sends text to **Groq API** to generate Tags.
    *   Calculates Vector Embeddings locally.
5.  **Celery** updates the Database record.
6.  **User** sees the tags appear automatically on refresh.

### Scenario B: Chatting with a Post (RAG Pipeline)
1.  **User** opens a blog post and types a question in the Chatbox.
2.  **WebSocket** connection sends the message to a **Django Channels Consumer**.
3.  **Consumer** performs a Vector Search:
    *   Converts user question to vector.
    *   Finds top 3 matching chunks from the Post's JSON embeddings.
4.  **Consumer** constructs a prompt (Context + Question) and sends it to **Groq API**.
5.  **Groq API** returns the answer token-by-token.
6.  **Consumer** streams the answer back to the User via WebSocket.

### Scenario C: Real-Time Notification
1.  **Reader** comments on **Author's** post.
2.  **Django View** saves the comment.
3.  **Code** checks if the Author is currently online (connected to WebSocket).
4.  **Redis Channel Layer** pushes a JSON payload to the Author's group (`user_<id>`).
5.  **Frontend** JavaScript receives the payload and updates the Bell Icon counter instantly without a page reload.

---

## üìê Design Patterns Used

1.  **Model-View-Template (MVT):** The standard architectural pattern of Django.
2.  **Observer Pattern (Pub/Sub):** Used in the Notification system. The system "publishes" an event (New Like), and the WebSocket "subscribes" to receive it.
3.  **Adapter Pattern:** Used in the AI Service (`ai_utils.py`) to adapt the external Groq API into a standard internal interface.
4.  **Repository Pattern:** (Implied) We keep business logic (like RAG retrieval) in `utils.py` files rather than bloating the Views/Consumers.

---

## üöÄ Scalability & Performance

*   **Concurrency:** Usage of **Daphne (ASGI)** allows handling thousands of concurrent WebSocket connections.
*   **Non-Blocking:** Heavy AI inference does not block the main thread because of **Celery**.
*   **Database:** The schema is normalized (3NF) to reduce redundancy.
*   **Caching:** Redis is used to cache frequent data access patterns (e.g., User Sessions).

```